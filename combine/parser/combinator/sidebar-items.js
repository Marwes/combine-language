initSidebarItems({"fn":[["and_then","Equivalent to [`p.and_then(f)`]."],["any_partial_state","Returns a parser where `P::PartialState` is boxed. Useful as a way to avoid writing the type since it can get very large after combining a few parsers."],["any_send_partial_state","Returns a parser where `P::PartialState` is boxed. Useful as a way to avoid writing the type since it can get very large after combining a few parsers."],["attempt","`attempt(p)` behaves as `p` except it acts as if the parser hadn't consumed any input if `p` fails after consuming input. (alias for `try`)"],["factory","Constructs the parser lazily on each `parse_*` call. This is similar to [`lazy`][] but it allows different parsers to be returned on each call to `p` while still reporting the correct errors."],["flat_map","Equivalent to [`p.flat_map(f)`]."],["from_str","Takes a parser that outputs a string like value (`&str`, `String`, `&[u8]` or `Vec<u8>`) and parses it using `std::str::FromStr`. Errors if the output of `parser` is not UTF-8 or if `FromStr::from_str` returns an error."],["lazy","Constructs the parser lazily on each `parse_*` call. Can be used to effectively reduce the size of deeply nested parsers as only the function producing the parser is stored."],["look_ahead","`look_ahead(p)` acts as `p` but doesn't consume input on success."],["map","Equivalent to [`p.map(f)`]."],["no_partial",""],["not_followed_by","Succeeds only if `parser` fails. Never consumes any input."],["opaque","Creates a parser from a function which takes a function that are given the actual parser. Though convoluted this makes it possible to hide the concrete parser type without `Box` or losing the full information about the parser as is the case of [`parser`][]."],["recognize","Constructs a parser which returns the tokens parsed by `parser` accumulated in `F: Extend<P::Input::Item>` instead of `P::Output`."],["try","`try(p)` behaves as `p` except it acts as if the parser hadn't consumed any input if `p` fails after consuming input."]],"struct":[["AndThen",""],["AnyPartialState",""],["AnyPartialStateParser",""],["AnySendPartialState",""],["AnySendPartialStateParser",""],["Factory",""],["FlatMap",""],["FromStr",""],["Ignore",""],["Lazy",""],["LookAhead",""],["Map",""],["NoPartial",""],["NotFollowedBy",""],["Opaque",""],["Recognize",""],["Try",""]],"trait":[["StrLike",""]],"type":[["FnOpaque","Alias over `Opaque` where the function can be a plain function pointer (does not need to capture any values)"]]});